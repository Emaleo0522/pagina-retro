<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaxian - JS Remake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #000;
            --text: #ff0;
        }

        body {
            background-color: #000;
            color: var(--text);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 3/4;
            background-color: #000;
            border: 2px solid #333;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 {
            background: linear-gradient(to bottom, #f00, #ff0, #00f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            filter: drop-shadow(2px 2px 0 #fff);
        }

        p {
            font-size: 0.8rem;
            line-height: 1.8;
            margin-bottom: 30px;
            color: #ccc;
        }

        .score-table span { display: inline-block; width: 150px; text-align: left; }
        
        button {
            background: transparent;
            color: #ff0;
            border: 2px solid #f00;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 5;
            font-size: 0.8rem;
            color: #f00;
        }
        
        #scoreVal { color: #fff; }

        /* Touch Controls */
        #controls {
            display: none;
            width: 100%;
            max-width: 600px;
            height: 140px;
            background: #111;
            padding: 10px 20px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #333;
        }

        @media (hover: none) and (pointer: coarse) {
            #controls { display: flex; }
            body { justify-content: flex-start; }
            #game-container { max-height: 65vh; }
        }

        .btn-arrow {
            width: 80px;
            height: 80px;
            background: #222;
            border: 2px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ff0;
            font-size: 30px;
            border-radius: 10px;
        }

        .btn-fire {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: #f00;
            border: 4px solid #800;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
        }

        .btn-arrow:active { background: #444; }
        .btn-fire:active { background: #f55; transform: scale(0.95); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="800"></canvas>
        
        <div id="hud">
            <div>HIGH SCORE <span id="highScoreVal">0</span></div>
            <div>SCORE <span id="scoreVal">0</span></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1>GALAXIAN</h1>
            <div class="score-table" style="text-align: left; font-size: 0.7rem; margin-bottom: 20px;">
                <p><span style="color:#ff0;">CHARGER</span> ...... POINTS</p>
                <p><span style="color:#20aefd;">DRONE</span> ........ 60</p>
                <p><span style="color:#a020f0;">EMISSARY</span> ..... 100</p>
                <p><span style="color:#f00;">HORNET</span> ....... 200</p>
                <p><span style="color:#ff0;">COMMANDER</span> .... 300</p>
            </div>
            <button onclick="startGame()">START MISSION</button>
        </div>

        <!-- Game Over -->
        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color: red;">GAME OVER</h1>
            <p>RESULTS</p>
            <p style="color: #ff0;">SCORE: <span id="finalScore">0</span></p>
            <button onclick="resetGame()">RETRY</button>
        </div>
        
         <!-- Wave Cleared -->
         <div id="levelScreen" class="overlay hidden">
            <h1 style="color: #20aefd;">SECTOR CLEARED</h1>
            <p>PREPARE FOR NEXT WAVE</p>
        </div>
    </div>

    <div id="controls">
        <div style="display:flex; gap: 20px;">
            <div class="btn-arrow" data-key="ArrowLeft">â—€</div>
            <div class="btn-arrow" data-key="ArrowRight">â–¶</div>
        </div>
        <div class="btn-fire" data-key="Space">ðŸ”¥</div>
    </div>

<script>
/**
 * GALAXIAN REMAKE
 * - Diving enemies (Bezier curves)
 * - Moving Starfield
 * - Full Color Sprites
 */

// --- Audio Engine ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
    } 
    else if (type === 'explosion') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
    else if (type === 'dive') {
        // Doppler-like effect
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.8);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0.0, now + 0.8);
        osc.start(now);
        osc.stop(now + 0.8);
    }
    else if (type === 'start') {
        osc.type = 'triangle';
        // Simple arp
        [440, 554, 659, 880].forEach((freq, i) => {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g);
            g.connect(audioCtx.destination);
            o.frequency.value = freq;
            o.type = 'square';
            g.gain.value = 0.05;
            o.start(now + i*0.1);
            o.stop(now + i*0.1 + 0.1);
        });
    }
}

// --- Constants ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GAME_W = 600;
const GAME_H = 800;
const SCALE = 3; 

// --- Sprites (Bitmaps) ---
// 1=Primary, 2=Secondary, 3=Eye/Accent
const SPRITES = {
    player: {
        w: 13, h: 13,
        map: [
            [0,0,0,0,0,0,2,0,0,0,0,0,0],
            [0,0,0,0,0,2,2,2,0,0,0,0,0],
            [0,0,0,0,0,2,3,2,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,3,1,1,0,0,0,0],
            [0,0,0,1,1,1,3,1,1,1,0,0,0],
            [0,0,1,1,1,1,3,1,1,1,1,0,0],
            [0,1,1,1,1,1,3,1,1,1,1,1,0],
            [1,1,1,1,1,1,3,1,1,1,1,1,1],
            [1,0,2,1,1,1,3,1,1,1,2,0,1],
            [1,0,2,1,0,0,0,0,0,1,2,0,1],
            [1,0,2,1,0,0,0,0,0,1,2,0,1]
        ],
        colors: { 1: '#fff', 2: '#f00', 3: '#ff0' }
    },
    // Green (Drone)
    enemy1: {
        w: 11, h: 8,
        map: [
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,1,1,1,0,0,0,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,1,2,1,1,1,1,1,2,1,1],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,1,0,0,0,0,0,0,0,1,0]
        ],
        colors: { 1: '#20aefd', 2: '#ff0' } // Blue/Yellow
    },
    // Purple (Emissary)
    enemy2: {
        w: 11, h: 8,
        map: [
            [0,0,0,0,1,1,1,0,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,2,1,1,1,1,1,2,1,1],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,1,0,1,0,0,0,1]
        ],
        colors: { 1: '#a020f0', 2: '#fff' } // Purple/White
    },
    // Red (Hornet)
    enemy3: {
        w: 11, h: 8,
        map: [
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,2,1,1,1,1,1,2,1,1],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,0,1,0,1,1,1,0],
            [0,0,1,0,0,1,0,0,1,0,0]
        ],
        colors: { 1: '#f00', 2: '#ff0' } // Red/Yellow
    },
    // Flagship (Galaxian)
    enemy4: {
        w: 13, h: 10,
        map: [
            [0,0,0,0,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,0,0,0,0],
            [0,0,1,1,1,2,1,2,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,3,1,1,1,1,1,1,1,3,1,1],
            [1,0,3,1,1,0,0,0,1,1,3,0,1],
            [0,0,0,1,0,0,0,0,0,1,0,0,0]
        ],
        colors: { 1: '#ff0', 2: '#f00', 3: '#20aefd' } // Yellow base
    }
};

// --- Game Variables ---
let score = 0;
let highScore = localStorage.getItem('galaxianHi') || 0;
let gameRunning = false;
let wave = 1;
let frameCount = 0;
let attacksAllowed = false; // Nueva variable para controlar inicio de ataques

let player = { x: GAME_W/2, y: GAME_H - 80, active: true };
let bullets = [];
let enemyBullets = [];
let particles = [];
let stars = [];

// The Swarm
let enemies = []; // {x, y, type, state, ox, oy, t}
// state: 'idle', 'dive', 'return'

const SWARM_OFFSET_X = 60;
const SWARM_OFFSET_Y = 100;
let swarmX = 0;
let swarmDir = 1;

// Inputs
const keys = { ArrowLeft: false, ArrowRight: false, ' ': false };

// --- Starfield ---
class Star {
    constructor() {
        this.x = Math.random() * GAME_W;
        this.y = Math.random() * GAME_H;
        this.speed = Math.random() * 2 + 0.5;
        this.color = Math.random() > 0.9 ? '#ff0' : (Math.random() > 0.8 ? '#f00' : '#888');
        this.size = Math.random() > 0.95 ? 2 : 1;
    }
    update(warp) {
        this.y += this.speed * (warp ? 5 : 1);
        if (this.y > GAME_H) {
            this.y = 0;
            this.x = Math.random() * GAME_W;
        }
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

// --- Enemy Logic ---
class Enemy {
    constructor(row, col, type) {
        this.gridRow = row;
        this.gridCol = col;
        this.type = type; // 'enemy1'...'enemy4'
        this.points = type === 'enemy1' ? 60 : type === 'enemy2' ? 100 : type === 'enemy3' ? 200 : 300;
        
        // Home position (relative to swarm center)
        this.hx = col * 40; 
        this.hy = row * 35;
        
        this.x = this.hx + SWARM_OFFSET_X;
        this.y = this.hy + SWARM_OFFSET_Y;
        this.angle = 0;
        
        this.state = 'idle'; // idle, dive
        this.t = 0; // Curve parameter
        this.curve = null; // {p0, p1, p2}
    }

    update() {
        if (this.state === 'idle') {
            this.x = swarmX + this.hx + SWARM_OFFSET_X;
            this.y = this.hy + SWARM_OFFSET_Y;
            this.angle = 0;
        } 
        else if (this.state === 'dive') {
            this.t += 0.01; // Velocidad de picada reducida (antes 0.015)
            
            // Quadratic Bezier
            const u = 1 - this.t;
            const tt = this.t * this.t;
            const uu = u * u;
            
            const p0 = this.curve.p0;
            const p1 = this.curve.p1;
            const p2 = this.curve.p2;
            
            const nx = (uu * p0.x) + (2 * u * this.t * p1.x) + (tt * p2.x);
            const ny = (uu * p0.y) + (2 * u * this.t * p1.y) + (tt * p2.y);
            
            // Calculate angle
            this.angle = Math.atan2(ny - this.y, nx - this.x) - Math.PI/2;
            
            this.x = nx;
            this.y = ny;

            // Shoot occasionally
            if (Math.random() < 0.03 && this.y < GAME_H - 100) {
                enemyBullets.push({x: this.x, y: this.y + 10, vy: 6});
            }

            // Loop back or reset
            if (this.t >= 1 || this.y > GAME_H + 20) {
                this.y = -50;
                this.state = 'idle';
            }
        }
    }

    startDive() {
        this.state = 'dive';
        this.t = 0;
        playSound('dive');
        
        const targetX = player.x + (Math.random() - 0.5) * 200;
        
        this.curve = {
            p0: { x: this.x, y: this.y },
            p1: { x: targetX, y: GAME_H / 2 },
            p2: { x: targetX + (Math.random() - 0.5) * 400, y: GAME_H + 50 }
        };
    }

    draw() {
        drawSprite(this.type, this.x, this.y, this.angle);
    }
}

// --- Drawing Helpers ---
function drawSprite(key, cx, cy, rotation) {
    const sprite = SPRITES[key];
    const w = sprite.w * SCALE;
    const h = sprite.h * SCALE;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation);
    ctx.translate(-w/2, -h/2);

    for (let r = 0; r < sprite.map.length; r++) {
        for (let c = 0; c < sprite.map[r].length; c++) {
            const val = sprite.map[r][c];
            if (val !== 0) {
                ctx.fillStyle = sprite.colors[val];
                ctx.fillRect(c * SCALE, r * SCALE, SCALE, SCALE);
            }
        }
    }
    ctx.restore();
}

function spawnExplosion(x, y, color) {
    for(let i=0; i<16; i++) { // MÃ¡s partÃ­culas para que se vea mejor
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 40 + Math.random() * 20, // MÃ¡s duraciÃ³n
            color: color
        });
    }
}

// --- Main Game Logic ---

function init() {
    for(let i=0; i<50; i++) stars.push(new Star());
    document.getElementById('highScoreVal').innerText = highScore;
    
    // Inputs
    window.addEventListener('keydown', e => {
        if(keys.hasOwnProperty(e.key) || e.code === 'Space') keys[e.key === ' ' ? ' ' : e.key] = true;
    });
    window.addEventListener('keyup', e => {
        if(keys.hasOwnProperty(e.key) || e.code === 'Space') keys[e.key === ' ' ? ' ' : e.key] = false;
    });
    
    const btns = document.querySelectorAll('.btn-arrow, .btn-fire');
    btns.forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[btn.dataset.key === 'Space' ? ' ' : btn.dataset.key] = true;
        });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[btn.dataset.key === 'Space' ? ' ' : btn.dataset.key] = false;
        });
    });

    setInterval(() => {
        if (!gameRunning) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,GAME_W,GAME_H);
            stars.forEach(s => { s.update(false); s.draw(); });
        }
    }, 50);
}

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('levelScreen').classList.add('hidden');
    
    score = 0;
    wave = 1;
    gameRunning = true;
    attacksAllowed = false; // Desactivar ataques al inicio
    player.active = true;
    player.x = GAME_W/2;
    playSound('start');
    
    createSwarm();
    
    // Retraso de 2 segundos antes de permitir ataques
    setTimeout(() => {
        attacksAllowed = true;
    }, 2000);

    requestAnimationFrame(gameLoop);
}

function createSwarm() {
    enemies = [];
    swarmX = 0;
    const layout = [
        'enemy4', 'enemy3', 'enemy2', 'enemy1', 'enemy1', 'enemy1'
    ];
    
    for (let r=0; r<layout.length; r++) {
        let type = layout[r];
        let cols = 10;
        let startCol = 0;
        if (type === 'enemy4') { cols = 2; startCol = 4; }
        
        for (let c=startCol; c<startCol+cols; c++) {
            enemies.push(new Enemy(r, c, type));
        }
    }
}

function resetGame() {
    startGame();
}

function update() {
    frameCount++;
    
    const enemiesDiving = enemies.some(e => e.state === 'dive');
    stars.forEach(s => s.update(enemiesDiving));

    // Si el jugador estÃ¡ activo, procesar input
    if (player.active) {
        if (keys.ArrowLeft && player.x > 30) player.x -= 5;
        if (keys.ArrowRight && player.x < GAME_W - 30) player.x += 5;

        if (keys[' '] && bullets.length === 0) {
            bullets.push({x: player.x, y: player.y - 20});
            playSound('shoot');
        }
    }

    // Swarm Movement
    swarmX = Math.sin(frameCount * 0.02) * 80;

    // Enemy AI - Solo si hay ataques permitidos
    if (attacksAllowed && player.active) {
        // Reducida la probabilidad de ataque para que no sea tan agresivo
        let diveChance = 0.005 + (wave * 0.001); // Antes 0.01 + wave*0.005
        let divers = enemies.filter(e => e.state === 'dive').length;
        
        // LÃ­mite de atacantes simultÃ¡neos reducido a 2 para empezar
        if (divers < 2 && Math.random() < diveChance) {
            const idles = enemies.filter(e => e.state === 'idle');
            if (idles.length > 0) {
                const attacker = idles[Math.floor(Math.random() * idles.length)];
                attacker.startDive();
            }
        }
    }

    enemies.forEach(e => e.update());

    // Update Player Bullets
    bullets.forEach((b, i) => {
        b.y -= 10;
        // Collision
        enemies.forEach((e, ei) => {
            if (Math.abs(b.x - e.x) < 20 && Math.abs(b.y - e.y) < 20) {
                score += e.points;
                if(e.state === 'dive') score += e.points;
                
                spawnExplosion(e.x, e.y, '#ff0');
                playSound('explosion');
                
                enemies.splice(ei, 1);
                bullets.splice(i, 1);
                
                document.getElementById('scoreVal').innerText = score;
            }
        });
        
        if (b.y < 0) bullets.splice(i, 1);
    });

    // Update Enemy Bullets
    enemyBullets.forEach((b, i) => {
        b.y += b.vy;
        // Solo chequear colisiÃ³n si el jugador estÃ¡ vivo
        if (player.active && Math.abs(b.x - player.x) < 15 && Math.abs(b.y - player.y) < 15) {
            playerDeath();
        }
        if (b.y > GAME_H) enemyBullets.splice(i, 1);
    });

    // Player vs Enemy Collision
    if (player.active) {
        enemies.forEach(e => {
            if (Math.abs(e.x - player.x) < 20 && Math.abs(e.y - player.y) < 20) {
                playerDeath();
            }
        });
    }

    // Particles (siempre actualizar para ver la explosiÃ³n final)
    particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    });

    // Level Clear
    if (enemies.length === 0) {
        wave++;
        gameRunning = false; // Detener temporalmente para mostrar cartel
        document.getElementById('levelScreen').classList.remove('hidden');
        setTimeout(() => {
            document.getElementById('levelScreen').classList.add('hidden');
            createSwarm();
            bullets = [];
            enemyBullets = [];
            attacksAllowed = false;
            gameRunning = true; // Reanudar
            
            // Retraso tambiÃ©n en nuevas oleadas
            setTimeout(() => {
                attacksAllowed = true;
            }, 2000);

            requestAnimationFrame(gameLoop);
        }, 3000);
    }
}

function playerDeath() {
    if (!player.active) return; // Evitar muertes dobles
    
    player.active = false;
    spawnExplosion(player.x, player.y, '#f00'); // ExplosiÃ³n roja grande
    playSound('explosion');
    
    // NO detener el juego inmediatamente.
    // Esperar 2 segundos viendo la explosiÃ³n y el caos restante.
    setTimeout(() => {
        gameRunning = false;
        document.getElementById('finalScore').innerText = score;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('galaxianHi', score);
            document.getElementById('highScoreVal').innerText = highScore;
        }
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }, 2000);
}

function draw() {
    // Clear
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    // Stars
    stars.forEach(s => s.draw());

    // Enemies
    enemies.forEach(e => e.draw());

    // Player (solo dibujar si estÃ¡ vivo)
    if (player.active) drawSprite('player', player.x, player.y, 0);

    // Bullets
    ctx.fillStyle = '#ff0';
    bullets.forEach(b => ctx.fillRect(b.x-2, b.y, 4, 10));

    ctx.fillStyle = '#f00';
    enemyBullets.forEach(b => ctx.fillRect(b.x-2, b.y, 4, 8));

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
}

function gameLoop() {
    if (!gameRunning) return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

init();

</script>
</body>
</html>
