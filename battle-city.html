<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battle City - JS Remake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #111;
            --accent: #e63946;
            --text: #f1faee;
        }

        body {
            background-color: #000;
            color: var(--text);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 13/13; /* Battle city grid ratio */
            background-color: #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            color: #e63946;
            font-size: 2.5rem; /* Ajustado para pantallas pequeñas */
            text-shadow: 4px 4px #000;
            margin-bottom: 20px;
            line-height: 1.2;
        }

        p {
            font-size: 0.8rem;
            line-height: 1.5;
            margin-bottom: 30px;
            color: #ccc;
        }

        button {
            background: var(--text);
            color: #000;
            border: 4px solid #555;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.95);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: right;
            pointer-events: none;
            z-index: 5;
            font-size: 0.8rem;
            text-shadow: 2px 2px 0 #000;
        }

        /* Touch Controls */
        #controls {
            display: none; /* Hidden on desktop by default */
            width: 100%;
            max-width: 600px;
            height: 180px;
            background: #222;
            padding: 10px;
            box-sizing: border-box;
            justify-content: space-between;
            align-items: center;
        }

        @media (hover: none) and (pointer: coarse) {
            #controls { display: flex; }
            body { height: 100vh; justify-content: flex-start; }
            #game-container { max-height: 60vh; }
        }

        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .d-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #444;
            border: 2px solid #666;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            user-select: none;
        }

        .d-btn:active { background: #666; }
        .d-up { top: 0; left: 40px; }
        .d-down { bottom: 0; left: 40px; }
        .d-left { top: 40px; left: 0; }
        .d-right { top: 40px; right: 0; }
        .d-center { top: 40px; left: 40px; background: #333; }

        .action-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #e63946;
            border: 4px solid #9c1c26;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            margin-right: 20px;
        }
        .action-btn:active { background: #ff4d5a; transform: scale(0.95); }

    </style>
</head>
<body>

    <!-- Botón de Volver al Menú -->
    <a href="index.html" style="
        position: fixed;
        top: 20px;
        left: 20px;
        color: white;
        text-decoration: none;
        font-family: 'Press Start 2P', monospace;
        z-index: 1000;
        background: rgba(0,0,0,0.8);
        padding: 12px 20px;
        border: 2px solid #e63946;
        text-transform: uppercase;
        font-size: 0.7rem;
        box-shadow: 0 0 15px rgba(230, 57, 70, 0.5);
        transition: all 0.3s;">
        ← Menú
    </a>

    <div id="game-container">
        <canvas id="gameCanvas" width="520" height="520"></canvas>

        <div id="hud">
            <div>SCORE: <span id="scoreVal">0</span></div>
            <div>HI: <span id="highScoreVal">0</span></div>
            <div>ENEMIES: <span id="enemiesVal">20</span></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1>BATTLE<br>CITY</h1>
            <p>1 JUGADOR<br>DEFIESTA LA BASE</p>
            <p style="font-size: 0.6rem; color: #888;">ARROWS/WASD: Mover | SPACE: Disparar</p>
            <button onclick="startGame()">START</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color: #fff;">GAME OVER</h1>
            <p id="endReason">BASE DESTRUIDA</p>
            <p>SCORE FINAL: <span id="finalScore">0</span></p>
            <button onclick="resetGame()">RETRY</button>
        </div>
        
         <!-- Victory Screen -->
         <div id="victoryScreen" class="overlay hidden">
            <h1 style="color: gold;">¡VICTORIA!</h1>
            <p>MISIÓN CUMPLIDA</p>
            <p>SCORE: <span id="victoryScore">0</span></p>
            <button onclick="resetGame()">JUGAR OTRA VEZ</button>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp">▲</div>
            <div class="d-btn d-left" data-key="ArrowLeft">◀</div>
            <div class="d-btn d-center"></div>
            <div class="d-btn d-right" data-key="ArrowRight">▶</div>
            <div class="d-btn d-down" data-key="ArrowDown">▼</div>
        </div>
        <div class="action-btn" data-key="Space">FIRE</div>
    </div>

<script>
/**
 * BATTLE CITY REMAKE
 * Engine & Logic
 */

// --- Constants & Config ---
const TILE_SIZE = 40; // Size of grid cell (13x13 grid = 520px)
const GRID_SIZE = 13;
const CANVAS_SIZE = TILE_SIZE * GRID_SIZE;
const PLAYER_SPEED = 3;
const BULLET_SPEED = 7;
const ENEMY_SPEED = 2;
const SPAWN_INTERVAL = 3000; // ms

// --- Audio System (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'explosion') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'brick') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
    } else if (type === 'steel') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.05, now);
        osc.start(now);
        osc.stop(now + 0.05);
    } else if (type === 'start') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554, now + 0.1);
        osc.frequency.setValueAtTime(659, now + 0.2);
        gain.gain.value = 0.1;
        osc.start(now);
        osc.stop(now + 0.6);
    }
}

// --- Game State ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let score = 0;
let highScore = localStorage.getItem('battleCityHi') || 0;
let enemiesRemaining = 20;
let enemySpawnTimer = 0;
let frameCount = 0;

// Inputs
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, 
    w: false, s: false, a: false, d: false, ' ': false
};

// Entities
let player;
let enemies = [];
let bullets = [];
let map = []; // 2D array
let explosions = [];

// Base Eagle Pos
const BASE_POS = { x: 6, y: 12 };
let baseActive = true;

// 0: Empty, 1: Brick, 2: Steel, 3: Water, 4: Trees, 9: Base
// Classic Battle City inspired map
const LEVEL_1 = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,2,2,2,1,0,1,2,2,2,1,0,1],
    [1,2,0,2,1,0,1,2,0,2,1,0,1],
    [1,2,0,2,1,0,1,2,0,2,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,0,1,1,2,1,1,0,1,1,1,1],
    [2,2,0,2,2,2,2,2,0,2,2,2,2],
    [0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,0,1,3,1,0,1,1,1,0,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,0,1,0,1,1,1,0,0,0],
    [0,1,1,1,0,9,0,1,1,1,0,0,0]
];

// --- Classes ---

class Bullet {
    constructor(x, y, dir, owner) {
        this.x = x;
        this.y = y;
        this.dir = dir; // 0: Up, 1: Right, 2: Down, 3: Left
        this.owner = owner; // 'player' or 'enemy'
        this.speed = BULLET_SPEED;
        this.width = 6;
        this.height = 6;
        this.active = true;
    }

    update() {
        if (!this.active) return;
        
        // Move
        if (this.dir === 0) this.y -= this.speed;
        if (this.dir === 1) this.x += this.speed;
        if (this.dir === 2) this.y += this.speed;
        if (this.dir === 3) this.x -= this.speed;

        // Screen bounds
        if (this.x < 0 || this.x > CANVAS_SIZE || this.y < 0 || this.y > CANVAS_SIZE) {
            this.active = false;
        }

        // Map Collisions (Brick/Steel/Base)
        this.checkMapCollision();
    }

    checkMapCollision() {
        // Simple center point collision is often enough, but let's do corners for precision
        let r = Math.floor(this.y / TILE_SIZE);
        let c = Math.floor(this.x / TILE_SIZE);

        // Check 4 corners just to be safe or center
        const centerX = this.x + this.width/2;
        const centerY = this.y + this.height/2;
        r = Math.floor(centerY / TILE_SIZE);
        c = Math.floor(centerX / TILE_SIZE);

        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
            const tile = map[r][c];
            if (tile === 1) { // Brick
                map[r][c] = 0; // Destroy
                this.active = false;
                playSound('brick');
                spawnExplosion(c * TILE_SIZE, r * TILE_SIZE, 'small');
            } else if (tile === 2) { // Steel
                this.active = false;
                playSound('steel');
                spawnExplosion(this.x, this.y, 'tiny');
            } else if (tile === 9) { // Base
                baseActive = false;
                map[r][c] = 0; // Destroy eagle visual
                this.active = false;
                spawnExplosion(c * TILE_SIZE, r * TILE_SIZE, 'big');
                endGame("BASE DESTRUIDA");
            }
        }
    }

    draw() {
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

class Tank {
    constructor(x, y, color, isPlayer) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.isPlayer = isPlayer;
        this.width = TILE_SIZE - 4;
        this.height = TILE_SIZE - 4;
        this.dir = 0; // 0:Up, 1:Right, 2:Down, 3:Left
        this.speed = isPlayer ? PLAYER_SPEED : ENEMY_SPEED;
        this.isMoving = false;
        this.cooldown = 0;
        this.active = true;
        
        // AI Stats
        this.changeDirTimer = 0;
    }

    update() {
        if (!this.active) return;

        if (this.cooldown > 0) this.cooldown--;

        if (this.isPlayer) {
            this.handlePlayerInput();
        } else {
            this.handleAI();
        }

        this.applyMovement();
    }

    handlePlayerInput() {
        this.isMoving = false;
        let dx = 0;
        let dy = 0;

        if (keys.ArrowUp || keys.w) { this.dir = 0; dy = -this.speed; this.isMoving = true; }
        else if (keys.ArrowDown || keys.s) { this.dir = 2; dy = this.speed; this.isMoving = true; }
        else if (keys.ArrowLeft || keys.a) { this.dir = 3; dx = -this.speed; this.isMoving = true; }
        else if (keys.ArrowRight || keys.d) { this.dir = 1; dx = this.speed; this.isMoving = true; }

        if (keys[' '] && this.cooldown <= 0) {
            this.shoot();
        }

        // Preview move with Corner Assist (Auto-Alignment)
        if (this.isMoving) {
            // Intento de movimiento directo
            if (!this.checkCollision(this.x + dx, this.y + dy)) {
                this.x += dx;
                this.y += dy;
            } else {
                // COLISIÓN DETECTADA: Asistencia de alineación
                // Si chocamos, intentamos deslizar el tanque hacia el centro de la baldosa más cercana
                // para que entre en el hueco suavemente.
                
                const assistSpeed = this.speed; 
                let slid = false;
                const tolerance = 20; // Píxeles de margen para corregir (mitad de un bloque)

                if (dy !== 0) { // Movimiento Vertical (Arriba/Abajo) -> Corregir eje X
                    const centerX = this.x + this.width / 2;
                    const col = Math.floor(centerX / TILE_SIZE);
                    const idealX = col * TILE_SIZE + (TILE_SIZE - this.width) / 2; // Posición centrada exacta
                    const diff = this.x - idealX;

                    // Si estamos desalineados pero cerca del hueco
                    if (Math.abs(diff) > 0 && Math.abs(diff) < tolerance) {
                        const slideDir = diff > 0 ? -1 : 1; // Deslizar hacia el centro
                        const sx = slideDir * assistSpeed;
                        
                        // Solo deslizar si no chocamos lateralmente
                        if (!this.checkCollision(this.x + sx, this.y)) {
                            this.x += sx;
                            slid = true;
                        }
                    }
                } else if (dx !== 0) { // Movimiento Horizontal (Izq/Der) -> Corregir eje Y
                    const centerY = this.y + this.height / 2;
                    const row = Math.floor(centerY / TILE_SIZE);
                    const idealY = row * TILE_SIZE + (TILE_SIZE - this.height) / 2; // Posición centrada exacta
                    const diff = this.y - idealY;

                    if (Math.abs(diff) > 0 && Math.abs(diff) < tolerance) {
                        const slideDir = diff > 0 ? -1 : 1;
                        const sy = slideDir * assistSpeed;
                        
                        if (!this.checkCollision(this.x, this.y + sy)) {
                            this.y += sy;
                            slid = true;
                        }
                    }
                }
                
                // Si la asistencia nos movió, intentamos aplicar también el movimiento hacia adelante
                // Esto hace que la entrada al pasillo sea fluida (diagonal) en lugar de escalonada
                if (slid) {
                     if (!this.checkCollision(this.x + dx, this.y + dy)) {
                        this.x += dx;
                        this.y += dy;
                    }
                }
            }
        }
    }

    handleAI() {
        // AI Logic: Move forward, if hit wall change dir, sometimes shoot
        this.changeDirTimer--;
        
        let dx = 0, dy = 0;
        if (this.dir === 0) dy = -this.speed;
        if (this.dir === 1) dx = this.speed;
        if (this.dir === 2) dy = this.speed;
        if (this.dir === 3) dx = -this.speed;

        let blocked = this.checkCollision(this.x + dx, this.y + dy);

        if (!blocked && this.changeDirTimer <= 0) {
             // 10% chance to change dir randomly while moving
             if (Math.random() < 0.02) blocked = true;
        }

        if (blocked || this.changeDirTimer <= 0) {
            // Pick new random direction
            this.dir = Math.floor(Math.random() * 4);
            this.changeDirTimer = Math.random() * 60 + 30; // 0.5 - 1.5s
        } else {
            this.x += dx;
            this.y += dy;
        }

        // Shoot randomly
        if (Math.random() < 0.02 && this.cooldown <= 0) {
            this.shoot();
        }
    }

    checkCollision(newX, newY) {
        // Boundary
        if (newX < 0 || newX + this.width > CANVAS_SIZE || newY < 0 || newY + this.height > CANVAS_SIZE) return true;

        // Tiles
        // Check all 4 corners of tank vs tiles
        const corners = [
            {r: Math.floor(newY / TILE_SIZE), c: Math.floor(newX / TILE_SIZE)},
            {r: Math.floor((newY + this.height) / TILE_SIZE), c: Math.floor(newX / TILE_SIZE)},
            {r: Math.floor(newY / TILE_SIZE), c: Math.floor((newX + this.width) / TILE_SIZE)},
            {r: Math.floor((newY + this.height) / TILE_SIZE), c: Math.floor((newX + this.width) / TILE_SIZE)}
        ];

        for (let pt of corners) {
            if (pt.r >= 0 && pt.r < GRID_SIZE && pt.c >= 0 && pt.c < GRID_SIZE) {
                const t = map[pt.r][pt.c];
                // 1=Brick, 2=Steel, 3=Water, 9=Base (Blocks movement)
                if (t === 1 || t === 2 || t === 3 || t === 9) return true;
            }
        }

        // Other Tanks
        // Player vs Enemy
        if (this.isPlayer) {
            for (let e of enemies) {
                if (e.active && rectIntersect(newX, newY, this.width, this.height, e.x, e.y, e.width, e.height)) return true;
            }
        } else {
            // Enemy vs Player
            if (player && player.active && rectIntersect(newX, newY, this.width, this.height, player.x, player.y, player.width, player.height)) return true;
            // Enemy vs Enemy (prevent stacking)
            for (let e of enemies) {
                if (e !== this && e.active && rectIntersect(newX, newY, this.width, this.height, e.x, e.y, e.width, e.height)) return true;
            }
        }

        return false;
    }

    applyMovement() {
        // Alignment help (optional polish, skipped for raw input feel)
    }

    shoot() {
        this.cooldown = 40; // Frames
        // Center bullet
        let bx = this.x + this.width / 2 - 3;
        let by = this.y + this.height / 2 - 3;
        
        // Spawn slightly outside tank to prevent self-collision issues (though logic handles it)
        if (this.dir === 0) by = this.y - 6;
        if (this.dir === 1) bx = this.x + this.width;
        if (this.dir === 2) by = this.y + this.height;
        if (this.dir === 3) bx = this.x - 6;

        bullets.push(new Bullet(bx, by, this.dir, this.isPlayer ? 'player' : 'enemy'));
        if (this.isPlayer) playSound('shoot');
    }

    draw() {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        // Rotate canvas to draw tank facing right, then rotate by dir
        // 0=Up (-90), 1=Right (0), 2=Down (90), 3=Left (180)
        let rotation = 0;
        if (this.dir === 0) rotation = -Math.PI / 2;
        if (this.dir === 2) rotation = Math.PI / 2;
        if (this.dir === 3) rotation = Math.PI;
        ctx.rotate(rotation);

        // Draw Tank Body
        ctx.fillStyle = this.color;
        // Tracks
        ctx.fillRect(-15, -15, 30, 8);
        ctx.fillRect(-15, 7, 30, 8);
        // Main Body
        ctx.fillStyle = this.isPlayer ? '#e9c46a' : '#ddd'; // Slight shade diff
        ctx.fillRect(-12, -8, 24, 16);
        // Turret
        ctx.fillStyle = this.color;
        ctx.fillRect(-6, -6, 12, 12);
        // Barrel
        ctx.fillRect(0, -3, 18, 6);

        // Decoration stripes (tracks)
        ctx.fillStyle = "#000";
        for(let i=-15; i<15; i+=4) {
            ctx.fillRect(i, -15, 1, 8);
            ctx.fillRect(i, 7, 1, 8);
        }

        ctx.restore();
    }
}

class Explosion {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.timer = type === 'big' ? 30 : 15;
        this.maxTimer = this.timer;
    }
    
    update() {
        this.timer--;
    }

    draw() {
        const radius = (this.maxTimer - this.timer) * (this.type === 'big' ? 2 : 1);
        ctx.beginPath();
        ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, radius, 0, Math.PI * 2);
        ctx.fillStyle = this.timer % 4 < 2 ? 'white' : 'red';
        ctx.fill();
        
        if (this.type === 'big') {
             ctx.strokeStyle = 'orange';
             ctx.lineWidth = 2;
             ctx.stroke();
        }
    }
}

// --- Logic Helpers ---

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function spawnExplosion(x, y, type) {
    explosions.push(new Explosion(x, y, type));
}

function resetMap() {
    // Deep copy level
    map = LEVEL_1.map(row => [...row]);
    
    // Ensure Base area is clear for spawning eagle
    map[12][6] = 9; 
    
    baseActive = true;
}

function spawnEnemy() {
    if (enemiesRemaining <= 0 || enemies.length >= 4) return;
    
    // Spawn points: Top Left, Top Center, Top Right
    const spawns = [{x:0, y:0}, {x:6, y:0}, {x:12, y:0}];
    const pt = spawns[Math.floor(Math.random()*spawns.length)];
    
    // Check if spawn blocked
    const sx = pt.x * TILE_SIZE;
    const sy = pt.y * TILE_SIZE;
    
    // Don't spawn on player
    if (rectIntersect(sx, sy, 36, 36, player.x, player.y, player.width, player.height)) return;

    // Type diff (color)
    const color = enemiesRemaining % 5 === 0 ? '#e63946' : '#fff'; // Red every 5th

    enemies.push(new Tank(sx, sy, color, false));
    enemiesRemaining--;
    updateHUD();
}

// --- Main Loops ---

function init() {
    document.getElementById('startScreen').classList.remove('hidden');
    document.getElementById('highScoreVal').innerText = highScore;
    
    // Keyboard listeners
    window.addEventListener('keydown', e => {
        if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = true;
        if (e.code === 'Space') keys[' '] = true;
    });
    
    window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) keys[e.key] = false;
        if (e.code === 'Space') keys[' '] = false;
    });

    // Touch Listeners
    setupTouchControls();
}

function setupTouchControls() {
    const btns = document.querySelectorAll('.d-btn, .action-btn');
    btns.forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            if (key) {
                if(key === 'Space') keys[' '] = true;
                else keys[key] = true;
            }
        });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            if (key) {
                if(key === 'Space') keys[' '] = false;
                else keys[key] = false;
            }
        });
    });
}

function startGame() {
    playSound('start');
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('victoryScreen').classList.add('hidden');
    
    score = 0;
    enemiesRemaining = 20;
    gameRunning = true;
    bullets = [];
    enemies = [];
    explosions = [];
    
    resetMap();
    
    // Spawn Player next to base
    player = new Tank(4 * TILE_SIZE, 12 * TILE_SIZE, '#ffb703', true); // Yellow tank
    
    updateHUD();
    gameLoop();
}

function updateHUD() {
    document.getElementById('scoreVal').innerText = score;
    document.getElementById('enemiesVal').innerText = enemiesRemaining;
}

function endGame(reason) {
    gameRunning = false;
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('endReason').innerText = reason;
    document.getElementById('finalScore').innerText = score;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('battleCityHi', highScore);
        document.getElementById('highScoreVal').innerText = highScore;
    }
}

function victory() {
    gameRunning = false;
    document.getElementById('victoryScreen').classList.remove('hidden');
    document.getElementById('victoryScore').innerText = score;
}

function gameLoop() {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
    // --- Update ---
    
    // Spawning
    enemySpawnTimer++;
    if (enemySpawnTimer > 100) { // Approx 1.6s
        spawnEnemy();
        enemySpawnTimer = 0;
    }

    if (enemiesRemaining === 0 && enemies.length === 0) {
        victory();
        return;
    }

    player.update();
    
    // Enemy Update & Collisions with Player Bullet
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update();
        
        // Check if hit by player bullet
        for (let b of bullets) {
            if (b.active && b.owner === 'player' && rectIntersect(b.x, b.y, b.width, b.height, e.x, e.y, e.width, e.height)) {
                e.active = false;
                b.active = false;
                score += 100;
                spawnExplosion(e.x, e.y, 'big');
                playSound('explosion');
                updateHUD();
            }
        }

        if (!e.active) enemies.splice(i, 1);
    }

    // Player vs Enemy Bullet
    for (let b of bullets) {
        if (b.active && b.owner === 'enemy' && rectIntersect(b.x, b.y, b.width, b.height, player.x, player.y, player.width, player.height)) {
            spawnExplosion(player.x, player.y, 'big');
            playSound('explosion');
            endGame("TE HAN DESTRUIDO");
            return;
        }
    }

    // Bullet vs Bullet (Destroy both)
    for (let i = 0; i < bullets.length; i++) {
        if (!bullets[i].active) continue;
        for (let j = i + 1; j < bullets.length; j++) {
            if (bullets[j].active && 
                rectIntersect(bullets[i].x, bullets[i].y, bullets[i].width, bullets[i].height,
                              bullets[j].x, bullets[j].y, bullets[j].width, bullets[j].height)) {
                bullets[i].active = false;
                bullets[j].active = false;
                break;
            }
        }
    }

    bullets.forEach(b => b.update());
    bullets = bullets.filter(b => b.active);
    
    explosions.forEach(ex => ex.update());
    explosions = explosions.filter(ex => ex.timer > 0);

    // --- Draw ---
    
    // 1. Draw Map
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE;
            let tile = map[r][c];
            
            if (tile === 0) continue; // Empty
            
            if (tile === 1) { // Brick
                ctx.fillStyle = '#a52a2a';
                ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                ctx.fillStyle = '#800000'; // Detail
                ctx.fillRect(x + 4, y + TILE_SIZE/2, TILE_SIZE - 8, 2);
            }
            else if (tile === 2) { // Steel
                ctx.fillStyle = '#ccc';
                ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.fillStyle = '#fff';
                ctx.fillRect(x + 10, y + 10, TILE_SIZE/2, TILE_SIZE/2);
            }
            else if (tile === 3) { // Water
                ctx.fillStyle = '#0077be';
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
            else if (tile === 9) { // Base (Eagle)
                if (baseActive) {
                    ctx.fillStyle = '#444'; // Background
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = '#e9c46a'; // Eagle
                    // Simple shape
                    ctx.beginPath();
                    ctx.moveTo(x + TILE_SIZE/2, y + 5);
                    ctx.lineTo(x + TILE_SIZE - 5, y + TILE_SIZE - 5);
                    ctx.lineTo(x + 5, y + TILE_SIZE - 5);
                    ctx.fill();
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(x + 15, y + 20, 10, 10);
                }
            }
        }
    }

    // 2. Draw Entities
    if (baseActive) {
        // Base is drawn in map loop
    }

    enemies.forEach(e => e.draw());
    if (player.active) player.draw();
    bullets.forEach(b => b.draw());
    explosions.forEach(ex => ex.draw());

    // 3. Trees (Draw over tanks) - optional but nice
    // ... skipping for clarity, but this would create hiding spots

    requestAnimationFrame(gameLoop);
}

// Reset Logic
function resetGame() {
    startGame();
}

// Start
init();

</script>
</body>
</html>
